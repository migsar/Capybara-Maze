# CapyMaze Quest ğŸ¦¦

**CapyMaze Quest** is a retro-styled procedural maze game built with **React**, **PixiJS**, and **Google Gemini API**. Navigate a capybara through infinite mazes, avoid predators, and unlock gates by solving AI-generated trivia questions.

## ğŸ® Game Overview

The player controls a Capybara using the keyboard. The goal of each level is to find the **Pond**.

*   **Grid:** Procedurally generated using a recursive backtracker algorithm.
*   **Hazards:** Predators (Jaguars/Crocodiles) patrol the maze. Contact loses a life.
*   **Bonuses:** Treats (Fruits) increase score.
*   **Gates:** Wooden logs block paths. To pass, you must answer a trivia question generated by the Gemini API based on a user-selected topic.

## ğŸ— Architecture

The application separates **Game State/Logic** from **React UI Rendering** using a hybrid approach.

### 1. The React Layer (`App.tsx`, `components/`)
*   **Responsibility:** Handles high-level application states (Menu, Playing, Game Over).
*   **UI Overlays:** Renders the HUD (Heads-up Display) for score/lives and the Trivia Modal.
*   **Service Integration:** Calls the Gemini Service for trivia.

### 2. The Game Engine (`classes/GameEngine.ts`)
*   **Responsibility:** Manages the PixiJS Application, the HTML Canvas, and the frame-by-frame game loop.
*   **Rendering:** Uses `pixi.js` to render the grid, walls, and entities as Sprites (Text objects used as sprites for this iteration).
*   **Physics:** Handles collision detection (AABB/Distance check) and movement interpolation.
*   **Event Bridge:** Communicates with React via a callback system (e.g., triggering the Trivia modal when a gate is hit).

### 3. Services
*   **`levelGenerator.ts`:** Pure logic for creating maze arrays (`number[][]`) and placing entities.
*   **`geminiService.ts`:** Interfaces with Google's GenAI SDK to fetch structured JSON trivia data.

## ğŸ›  Tech Stack

*   **Frontend Framework:** React 19
*   **Rendering Engine:** PixiJS (v8)
*   **Styling:** TailwindCSS
*   **AI:** Google Gemini API (`gemini-2.5-flash`)
*   **Language:** TypeScript

## ğŸ“‚ Project Structure

```
â”œâ”€â”€ classes/
â”‚   â””â”€â”€ GameEngine.ts       # Core PixiJS game loop and renderer
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Game.tsx            # React wrapper for GameEngine + UI Overlays
â”‚   â””â”€â”€ MainMenu.tsx        # Config screen
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ geminiService.ts    # AI Generation
â”‚   â””â”€â”€ levelGenerator.ts   # Maze Algorithms
â”œâ”€â”€ constants.ts            # Config, Assets (Emojis), Translations
â”œâ”€â”€ types.ts                # TypeScript interfaces and Enums
â””â”€â”€ App.tsx                 # Main State Controller
```

## ğŸ§© Key Programming Patterns

### The "Engine-Bridge" Pattern
Because PixiJS runs on its own `requestAnimationFrame` ticker, passing React state down to it on every frame is inefficient. Instead:
1.  React instantiates `GameEngine` inside a `useEffect` (on mount).
2.  React subscribes to events from the Engine (`GATE_HIT`, `GAME_OVER`).
3.  React calls public methods on the Engine (`engine.loadLevel()`, `engine.resume()`).

### Procedural Generation
The maze uses a **Recursive Backtracker** algorithm ensuring a perfect maze (no loops, all accessible). We then run a post-processing pass to remove ~5% of walls to create loops, making the gameplay more dynamic and less frustrating.

### AI Integration
The `geminiService` requests JSON-structured data (`responseMimeType: "application/json"`) to ensure the trivia questions can be reliably parsed and displayed by the UI, rather than dealing with unstructured text.

## ğŸ¨ Visuals & Assets

*   **Style:** Retro Pixel Art vibe.
*   **Font:** `VT323` (Google Fonts).
*   **Sprites:** To maintain a lightweight footprint without external image dependencies, the game currently uses **Emoji** rendered via `PIXI.Text`. This allows for high-quality, scalable "sprites" that work instantly in any browser.

## ğŸš€ Development Guidelines

1.  **Modifying the Game Loop:** Edit `GameEngine.ts`. The `update()` method runs every frame.
2.  **Changing Assets:** Update `constants.ts`. If you switch to real image files, update `GameEngine.ts` to use `Sprite.from('path/to/img')` instead of `new Text(...)`.
3.  **Adding Languages:** Add entries to `TRANSLATIONS` in `constants.ts`. The logic automatically handles localized strings.

## âš ï¸ Common Pitfalls

*   **React Strict Mode:** React 18+ mounts components twice in dev. The `useEffect` in `Game.tsx` has cleanup logic (`engine.destroy()`) to prevent two Canvases from appearing.
*   **Grid Access:** Always check bounds when moving entities. The logic `if (grid[y] && grid[y][x])` prevents generic "undefined" errors.

---
*Created by a Senior Frontend AI Engineer.*
